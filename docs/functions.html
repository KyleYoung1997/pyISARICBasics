<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyISARICBasics.functions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyISARICBasics.functions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import gc
import os
import sqlite3
import pandas as pd
import numpy as np

ALL_DOMAINS = {&#34;DM&#34;, &#34;DS&#34;, &#34;ER&#34;, &#34;HO&#34;, &#34;IE&#34;, &#34;IN&#34;, &#34;LB&#34;, &#34;MB&#34;, &#34;RP&#34;, &#34;RS&#34;, &#34;SA&#34;, &#34;SV&#34;, &#34;VS&#34;, &#34;CQ&#34;, &#34;SC&#34;, &#34;PO&#34;}
&#34;&#34;&#34;
A set containing all possible domains in the ISARIC dataset. 
&#34;&#34;&#34;


### TODO write custom .hdf5 loader and saver functions for QUICKEST I/O
### This could be tricky -&gt; it seems like the best option is to convert dtypes from object to pandas d types
### but then we need to handle stuff differently in other places in code...
### We also need to try and deal with the fact that it seems like df.to_hdf() freaks out with DF&#39;s over a certain size
### You can load and append using hdf but I am not sure how yet -&gt; you can also query using hdf this is definitely worth
### looking into though.

def csv_to_sqlite(data_folder, db_file, overwrite=True):
    &#34;&#34;&#34;
    Converts all raw .csv files to a sqlite database

    :param data_folder: Location of folder where data is contained

    :param db_file: Name of sqlite databse within data_folder

    :param overwrite: Rewrite sqlite database if it already exists

    :return: Null
    &#34;&#34;&#34;
    # if os.path.isfile(os.path.join(data_folder, db_file)):
    #     print(&#34;Database already exists&#34;)
    #     return
    for file in os.listdir(data_folder):  # get all files in data_folder
        if file.endswith(&#34;.csv&#34;):  # get csv files
            name = os.path.splitext(file)[0]  # file name with no extension
            name = parse_domain_names(name)
            name = name.replace(&#39;-&#39;, &#39;_&#39;)  # replace - with _ to avoid sql errors.
            print(&#34;_&#34; * 150)
            print(&#34;Creating table:&#34;, name)
            file_path = os.path.join(data_folder, file)

            df = pd.read_csv(file_path, on_bad_lines=&#39;skip&#39;, verbose=False)
            df = df.rename(columns=lambda x: x.strip())
            # print(df.dtypes)
            # df = df.convert_dtypes()
            #
            # print(df.dtypes)
            print(&#34;Length of df &#34;, name, len(df))
            df_to_sqlite(df, name, data_folder, db_file, overwrite)
            del df
            gc.collect()


def df_to_sqlite(df, table_name, data_folder, data_file, overwrite=True):
    &#34;&#34;&#34;
    Creates a table in sqlite database using the supplied dataframe, also saves .pickle files for each table saved to
    the sql database (these are much quicker to load in to memory using Python and Pandas).

    :param df: Dataframe to convert to sqlite table

    :param table_name: Table name of dataframe (to be saved as in database)

    :param data_folder: Location of folder where data is contained

    :param data_file: db_file: Name of sqlite database within data_folder

    :param overwrite: overwrite: Rewrite sqlite database if it already exists

    :return: True, if write successful
    &#34;&#34;&#34;
    # Executes a query and returns a pandas dataframe
    # query is a string.
    # data_folder is the folder that sqlite file is in.
    # data_file is the name of sqlite file.
    if overwrite:
        if_exists = &#39;replace&#39;
    else:
        if_exists = None
    try:
        db_file = os.path.join(data_folder, data_file)
        con = sqlite3.connect(db_file)  # connection to the database file
        df.to_sql(table_name, con, if_exists=if_exists, index=False)
        save_string = os.path.join(data_folder, f&#34;{table_name}.pickle&#34;)
        df.to_pickle(save_string)
        del df
        gc.collect()
        return True
    except ValueError as e:
        print(&#34;Table already exists in database, set Overwrite = True if you wish to overwrite existing table.&#34;)
        return None
    finally:
        con.close()


def parse_domain_names(name: str) -&gt; str:
    &#34;&#34;&#34;
    Function to read domain name and return two letter abbreviation for each domain

    :param name: (str) filename similar to &#34;Partner_DM_2021-09-20.csv&#34;

    :return: (str) Two letter abbreviated domain name e.g. &#34;DM&#34; for above filename
    &#34;&#34;&#34;
    domain = [i for i in name.split(&#34;_&#34;) if i in ALL_DOMAINS]
    if len(domain) &gt; 1:
        print(&#34;Couldn&#39;t parse domain name from filename returning full path as domain name&#34;)
        return name
    else:
        return domain.pop()</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pyISARICBasics.functions.ALL_DOMAINS"><code class="name">var <span class="ident">ALL_DOMAINS</span></code></dt>
<dd>
<div class="desc"><p>A set containing all possible domains in the ISARIC dataset.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyISARICBasics.functions.csv_to_sqlite"><code class="name flex">
<span>def <span class="ident">csv_to_sqlite</span></span>(<span>data_folder, db_file, overwrite=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts all raw .csv files to a sqlite database</p>
<p>:param data_folder: Location of folder where data is contained</p>
<p>:param db_file: Name of sqlite databse within data_folder</p>
<p>:param overwrite: Rewrite sqlite database if it already exists</p>
<p>:return: Null</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csv_to_sqlite(data_folder, db_file, overwrite=True):
    &#34;&#34;&#34;
    Converts all raw .csv files to a sqlite database

    :param data_folder: Location of folder where data is contained

    :param db_file: Name of sqlite databse within data_folder

    :param overwrite: Rewrite sqlite database if it already exists

    :return: Null
    &#34;&#34;&#34;
    # if os.path.isfile(os.path.join(data_folder, db_file)):
    #     print(&#34;Database already exists&#34;)
    #     return
    for file in os.listdir(data_folder):  # get all files in data_folder
        if file.endswith(&#34;.csv&#34;):  # get csv files
            name = os.path.splitext(file)[0]  # file name with no extension
            name = parse_domain_names(name)
            name = name.replace(&#39;-&#39;, &#39;_&#39;)  # replace - with _ to avoid sql errors.
            print(&#34;_&#34; * 150)
            print(&#34;Creating table:&#34;, name)
            file_path = os.path.join(data_folder, file)

            df = pd.read_csv(file_path, on_bad_lines=&#39;skip&#39;, verbose=False)
            df = df.rename(columns=lambda x: x.strip())
            # print(df.dtypes)
            # df = df.convert_dtypes()
            #
            # print(df.dtypes)
            print(&#34;Length of df &#34;, name, len(df))
            df_to_sqlite(df, name, data_folder, db_file, overwrite)
            del df
            gc.collect()</code></pre>
</details>
</dd>
<dt id="pyISARICBasics.functions.df_to_sqlite"><code class="name flex">
<span>def <span class="ident">df_to_sqlite</span></span>(<span>df, table_name, data_folder, data_file, overwrite=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a table in sqlite database using the supplied dataframe, also saves .pickle files for each table saved to
the sql database (these are much quicker to load in to memory using Python and Pandas).</p>
<p>:param df: Dataframe to convert to sqlite table</p>
<p>:param table_name: Table name of dataframe (to be saved as in database)</p>
<p>:param data_folder: Location of folder where data is contained</p>
<p>:param data_file: db_file: Name of sqlite database within data_folder</p>
<p>:param overwrite: overwrite: Rewrite sqlite database if it already exists</p>
<p>:return: True, if write successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df_to_sqlite(df, table_name, data_folder, data_file, overwrite=True):
    &#34;&#34;&#34;
    Creates a table in sqlite database using the supplied dataframe, also saves .pickle files for each table saved to
    the sql database (these are much quicker to load in to memory using Python and Pandas).

    :param df: Dataframe to convert to sqlite table

    :param table_name: Table name of dataframe (to be saved as in database)

    :param data_folder: Location of folder where data is contained

    :param data_file: db_file: Name of sqlite database within data_folder

    :param overwrite: overwrite: Rewrite sqlite database if it already exists

    :return: True, if write successful
    &#34;&#34;&#34;
    # Executes a query and returns a pandas dataframe
    # query is a string.
    # data_folder is the folder that sqlite file is in.
    # data_file is the name of sqlite file.
    if overwrite:
        if_exists = &#39;replace&#39;
    else:
        if_exists = None
    try:
        db_file = os.path.join(data_folder, data_file)
        con = sqlite3.connect(db_file)  # connection to the database file
        df.to_sql(table_name, con, if_exists=if_exists, index=False)
        save_string = os.path.join(data_folder, f&#34;{table_name}.pickle&#34;)
        df.to_pickle(save_string)
        del df
        gc.collect()
        return True
    except ValueError as e:
        print(&#34;Table already exists in database, set Overwrite = True if you wish to overwrite existing table.&#34;)
        return None
    finally:
        con.close()</code></pre>
</details>
</dd>
<dt id="pyISARICBasics.functions.parse_domain_names"><code class="name flex">
<span>def <span class="ident">parse_domain_names</span></span>(<span>name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Function to read domain name and return two letter abbreviation for each domain</p>
<p>:param name: (str) filename similar to "Partner_DM_2021-09-20.csv"</p>
<p>:return: (str) Two letter abbreviated domain name e.g. "DM" for above filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_domain_names(name: str) -&gt; str:
    &#34;&#34;&#34;
    Function to read domain name and return two letter abbreviation for each domain

    :param name: (str) filename similar to &#34;Partner_DM_2021-09-20.csv&#34;

    :return: (str) Two letter abbreviated domain name e.g. &#34;DM&#34; for above filename
    &#34;&#34;&#34;
    domain = [i for i in name.split(&#34;_&#34;) if i in ALL_DOMAINS]
    if len(domain) &gt; 1:
        print(&#34;Couldn&#39;t parse domain name from filename returning full path as domain name&#34;)
        return name
    else:
        return domain.pop()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyISARICBasics" href="index.html">pyISARICBasics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pyISARICBasics.functions.ALL_DOMAINS" href="#pyISARICBasics.functions.ALL_DOMAINS">ALL_DOMAINS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyISARICBasics.functions.csv_to_sqlite" href="#pyISARICBasics.functions.csv_to_sqlite">csv_to_sqlite</a></code></li>
<li><code><a title="pyISARICBasics.functions.df_to_sqlite" href="#pyISARICBasics.functions.df_to_sqlite">df_to_sqlite</a></code></li>
<li><code><a title="pyISARICBasics.functions.parse_domain_names" href="#pyISARICBasics.functions.parse_domain_names">parse_domain_names</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>